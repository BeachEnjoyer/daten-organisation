---
# bibliography: references.bib

title: Versionierung mit Git und GitHub

abstract: ""

execute: 
  echo: false
---

> Versionierung ist ein Prozess, bei dem Änderungen an einem Dokument oder einer Datei nachverfolgt werden.

Die meisten Cloud-Dienste  bieten inzwischen das Speichern von Dateiversionen an. Diese Funktionen sind in der Regel so gelöst, dass die Datei in regelmässigen Abständen gespeichert wird, so dass eine *zeitliche* Abfolge von geänderten Versionen entsteht. Für manche Dateiformate ist es möglich, einzelne Änderungen des Inhalts nachzuvollziehen.

> Für die Arbeit mit Daten ist das Versionsmanagement wichtig, damit das Datenmanagement durcgängig und nachvollziehbar ist. 

Das regelmässige Speichern von Dateien ist der Startpunkt für die eigentliche Versionierung, dem *Versionsmanagement* oder der *Versionskontrolle* (engl. Version Control).

Bei der Versionierung werden die Änderungen an einer Datei festgehalten und mit einer Versions*nummer* gespeichert. Der entscheidende Unterschied zum regelmässigen Speichern auf Cloud-Diensten ist, dass einzelne Versionen für den späteren Gebrauch oder zur späteren Kontrolle markiert und wiederhergestellt werden können. Die Versionskontrolle stellt sicher, dass für jede Datei die jeweils aktuelle Version eindeutig definiert ist.

Die Versionierung betrifft alle erzeugenden Projektdateien. Dazu gehören: 

- Datendateien
- Code-Dateien
- Code-Konfiguration
- Projektkonfiguration 
- Dokumentation

Es gibt verschiedene Systeme für die Versionierung. Im Bereich der Software-Entwickung und den Datenwissenschaften hat sich `git` als Industriestandard etabliert.

`git` ist ein verteiltes Versionierungssystem. *Verteilt* bedeutet dabei, dass die Versionierung mit allen teilnehmenden Systemen vollständig geteilt wird und es keine zentrale Instanz für die Versionierung gibt. Es handelt sich daher um ein redundantes *Peer-to-Peer*-System. `git` unterteilt die Versionierung in Projekte, den sog. ***Repositories***, dass auf verschiedenen Computern repliziert bzw. ge-**cloned**  wird. Dadurch erhält jeder Computer mit einem Repository-Clone eine vollständige Kopie der Versionierung eines Projekts. 

Diese Kurzeinführung stellt die zentralen `git`-Konzepte für die tägliche Arbeit vor:

- `git` installieren
- Repositories, Clone und Forks
- Dateiversionen einem Repository hinzufügen (commit)
- Pull und Push
- Branches, Merges und Pull-Requests

## `git` installieren

`git` besteht im wesentlichen aus einem Kommandozeilen-Werkzeug, das alle Funktionen von `git` bereitstellt. Dieses Werkzeug wird oft auch als *CLI-Tool* bezeichnet. Es für die meisten GUI-Apps die Voraussetzung für die Arbeit. Ausserdem stellen nicht alle GUI-Apps alle `git`-Funktionen bereit und gelegentlich kann es in Spezialfällen notwendig sein, `git` direkt zu verwenden. Deshalb sollte `git` immer auf einem Computer installiert sein. 

### `git` unter MacOS installieren

Es wird dringend empfohlen die offiziell von Apple vertriebene Version von `git` zu verwenden.

Unter MacOS ist `git` Teil der internen Entwicklungsumgebung. Dazu sollte [XCode](https://apps.apple.com/gb/app/xcode/id497799835) installiert sein. XCode muss mindestens einmal gestartet worden sein, damit die Lizenzbedingungen erstmalig akzeptiert werden. Anschliessend müssen die [XCode Command Line Tools](https://developer.apple.com/download/all/?q=command%20line%20tools) dem System hinzugefügt werden. Wählen Sie die Version dieser Tools immer so aus, dass sie zu der von Ihnen installierten Version von XCode passt. Für diesen Download benötigen Sie einen Entwicker-Account auf Apple's Entwicklerplattform. Dieser Account ist kostenlos. Nach der Installation der XCode Command Line Tools ist auch `git` auf Ihrem Rechner installiert. 

### `git` unter Windows installieren

Unter Windows stellt das Projekt [git for Windows](https://gitforwindows.org/) eine für Windows Systeme angepasste Version von `git` bereit. Diese Version bietet neben `git` zusätzliche Werkzeuge, mit denen sich Anleitungen leichter nachvollziehen lassen. 

### Grafische Oberflächen für `git`

GUI-Apps die Arbeit mit `git`. Für die Arbeit mit diesem Buch werden die folgenden Werkzeuge empfohlen. 

- [Visual Studio Code](https://code.visualstudio.com/download) unterstützt `git` in der Basisinstallation. 
- Die Erweiterung [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) bindet zusätzliche Funktionen für das Versionsmangement direkt in Visual Studio Code ein.
- [GitHub Desktop](https://desktop.github.com/) stellt eine einfache Benutzeroberfläche für die Basisaufgaben am Computer Desktop bereit. 
- [GitKraken](https://www.gitkraken.com/) bietet unfangreiche Funktionen zum Versionsmanagement mit `git`. 

### Online Plattformen für `git` Repositories

`git` ist zuerst auf den eigenen Computer beschränkt. Für das Zusammenarbeiten mit anderen und die Sicherung der eigenen Versionierung empfielt sich die Verwendung einer sog. `git`-Hosting-Plattform. Eine `git`-Hosting-Plattform erlaubt es die Versionierung eines Projekts online zu sichern und mit anderen zu teilen, die bietet Projektmanagementfunktionen sowie Automatisierungsmöglichkeiten, die über die Kernfunktionen von `git` hinausgehen. 

Die wichtigsten `git`-Hosting-Plattformen mit gleichwertigem Funktionsumfang sind:

- [GitHub](https://github.com)
- [GitLab](https://gitlab.com)
- [Gitea](https://gitea.com)

Jede dieser Plattformen benötigt ein eigenes Benutzerkonto.

> Dieses Buch verwendet ***GitHub*** für Code-Beispiele, Diskussionen und andere Funktionen. ***GitLab*** und ***Gittea*** sind Alternativen zu GitHub mit gleichwertigen Funktionsumfang  und ähneln sich  bei der Bedienung und im Funktionsumfang stark. Aus Sicht der Projektorganisation sind die Plattformen fast identisch. Es gibt vor Allem emotionale und wirtschaftliche Gründe, sich für die eine oder die andere Plattform zu entscheiden.

## `git`-Konzepte

### Repositories, Clones und Forks

### Versionierung durch Commits

- Add
- Commit 
- messages 

- remove

### Pull und Push 

### Tags

Tags sind spezielle Markierungen von Verionen in einem git-Repository.

### Branching und Merging

Das letzte wichtige Konzept sind sog. *Branches*. Ein Branch ist ein vom `main`-Zweig abgeleiteter Versionspfad.  

#### Merge-Konflikte lösen

Gelegentlich entstehen beim Mergen Konflikte. Ein Merge-Konflikt sind widersprüchliche Inhalte an der gleichen Code-Position. `git` löst solche Widersprüche nicht selbst, sondern erfordert . 

Solche Konflikte können auch entstehen, wenn mehrere Personen gleichgzeitig auf dem gleichen Branch arbeiten. 


#### Rebase

## Projektmanagement

### Issues

> `git`-Hosting-Plattformen unterstützen sog. *Action-Keywords* in Commit-Meldungen. Wird ein solches Keyword zusammen mit der Issue-Nummer verwendet, dann schliesst die Hosting-Plattform das genannte Issue automatisch. 

### Pull Requests

Wenn Code in zwei Code-Zweigen zusammengeführt werden soll, werden sog. ***Pull-Requests*** bzw. ***Merge-Requests*** erstellt. Ein Pull-Request ist eine Anfrage zum Zusammenführen. Weil dieser Arbeitsschritt gelegentlich zu Problemen führt, 

> Ursprünglich wurden Pull-Requests in Form von E-Mails an die Projektkoordination geschickt und enthieleten einen Verweis auf den einzubindenen Fork. In `git`-Hosting-Plattformen sind Pull-Requests spezielle Issues, die einen Branch oder einen Fork mit dem Repository verknüpfen. 


### Wiki

Ein Wiki ist ein separates git-Repository für die Dokumentation.

## Anwendungen und Praxistipps

### Dateien und Verzeichnisse von der Versionierung ausschliessen

`git` meldet "nicht verfolgte"-Dateien, um Datenverlusten vorzubeugen. Nicht alle Dateien in einem Projekt müssen oder sollten versioniert werden. Das gilt meist für die folgenden Kategorien.

- Dateien des Betriebssystems
- Konfigurationsdateien
- Hilfsmodule und Komponenten von Dritten
- Temporäre Dateien und Zwischenergebnisse
 
Damit diese Dateien nicht versehentlich in der Versionierung erfasst werden, sollten sie aus dem Prozess ausgenommen werden. Dateien und Verzeichnisse können von der Versionierung ausgenommen werden, indem sie in der Datei `.gitignore` erwähnt werden. `.gitignore` kann gezielt einzelne Namen oder Namesmuster ausklammern. `.gitignore` ist Teil der versionierten Daten, so dass sauber nachvollziehbar ist, welche Dateien aus der Versionierung ausgenommenen werden sollten. 

Eine Datei wird nur ignoriert, wenn sich noch nicht in der Versionierung erfasst wurde.

> **Achtung!** Eine Datei wird von der Versionierung ausgeschlossen, wenn eine der folgenden Regeln zutrifft.

- Der Datei- oder Verzeichnisname ist explizit in `.gitignore` gelistet. Für Namen in Unterverzeichnissen muss dazu der Gesamtepfad angegeben sein.
- Eine Datei oder ein Verzeichnis liegt in einem Verzeichnis, dass ignoriert wird. 
- Der Datei- oder Verzeichnisname wird durch ein Namesmuster erfasst.

Die folgenden Namesmuster sind gebräuchlich:

- `*/dateiname` - eine Datei oder ein Verzeichnis mit einem bestimmten Namen liegt in einem Verzeichnis im Projektverzeichnis. 
- `**/dateiname` - eine Datei oder ein Verzeichnis liegt an beliebiger Stelle im Projekt
- `*.tmp` - alle Dateien oder Verzeichnisse im Projektverzeichnis, die auf `.tmp` enden. 
- `bild*` - alle Dateien oder Verzeichnisse im Projektverzeichnis, die mit `bild` beginnen. 

> Gelegentlich kommt es vor, dass festgestellt wird, dass eine oder mehrere Dateien ignoriert werden soll, obwohl sie bereits in die Versionierung aufgenommen wurde. In diesem Fall erscheit es, als ob `.gitignore` nicht funktioniert. Das liegt daran, dass `git` eine Datei nur ignoriert, wenn diese nicht in der Versionierung erfasst wurde.  Um eine bereits erfasste Datei zu irgnorieren, muss diese Datei aus dem Versionsdatenbank mit `git rm` entfernt werden.

**Beispiel**

Das folgende Beispiel zeigt typische `.gitignore`-Datei für ein R-Projekt. 

```gitignore
# Ignore MacOS Filesystem Metadata
**/.DS_Store

# R-specific Files
.Rhistory
.Rapp.history
.RData
.RDataTmp
.Ruserdata
.Renviron

*-Ex.R

/*.tar.gz
/*.Rcheck/
.Rproj.user/

vignettes/*.html
vignettes/*.pdf

rsconnect/
.httr-oauth

*_cache/
/cache/
*.utf8.md
*.knit.md
po/*~
_bookdown_files/
_book
.quarto/
/.quarto/
```

### Branching Strategien

Es werden drei zentrale Branching-Strategien unterschieden. 

- Git Flow
- GitLab Flow 
- GitHub Flow

Für datenzentrische Projekte ist der GitFlow am leichtesten zur handhaben und erfordert 

#### Git Flow

Der Git Flow ist der klassische Weg, um Coding-Projekte zu organisieren. 

- main
- release
- hotfix
- develop
- feature

#### GitLab flow

multiple release branches

main is development branch 

Jedes Release wird in einem eigenen Branch geführt. 

#### GitHub flow

Kein unterschied zwischen Main, development und release branch.

```{mermaid}
%%{init: {'theme': 'base' } }%%
gitGraph
   commit
   commit
   branch issue_1
   checkout issue_1
   commit
   checkout issue_1
   commit
   checkout main
   merge issue_1
   commit tag:"v1.0.0"
```

Aufgabenbasierte Branches 

Sobald eine Aufgabe abgeschlossen ist, wird ein Merge durchgeführt und der zugehörige Aufgaben-Branch "entfernt". Technisch wird nur die Verzweigung vom `main`-Branch entfernt, weil die Versionierung beim Merge erhalten bleibt. Dadurch wird sichergestellt, dass an dieser Aufgabe nicht versehentlich weiter gearbeitet wird. 

### Repository-Organisation

Die Arbeit mit Git und den anderen Hosting-Plattformen erscheint oft mühsam und aufwändig. Das gilt speziell für grösseres Umorganisieren eines Repositories. Gerade bei komplexen Projekten sollte deshalb möglichst früh die Organisation des Versionsmanagements festgelegt werden.  

In der Praxis finden sich drei Organisationsstrategien. 

1. Monorepo
2. Projektrepo
3. Microrepo

Die Wahl der Repository-Organisation hängt stark von den Projektanforderungen ab. 

#### Monorepo

Bei der Monorepo-Strategie werden alle Dateien in einem einzigen Repository organisiert. Diese Strategie ist besonders bei Projektbeginn oder bei einfachen Projekten mit geringer funktionaler Trennung geeignet. Der Vorteil dieser Strategie ist, dass alle Daten in einem Repository zusammengefasst vorliegen und als Ganzes verwaltet werden können. 

Für komplexe Projekte wird diese Organisationsstrategie normalerweise mit dem Git-Flow als Branching-Strategie kombiniert. Dabei müssen alle Projektteile aufeinander abgestimmt werden und benötigen eine konsitente Qualitätskontrolle, weil alle Änderungen voneinander abhängig sind. Komplexe Änderungen beeinflussen wegen der linearen Abhängigkeit der Versionen deshalb alle anderen Bereich und sind deshalb wesentlich schwerer zu korrigieren.

#### Projektrepo

Die Projektrepo-Strategie ist eine Variante der Monorepo-Strategie für komplexe Projekte, mit klar getrennten aber voneinander abhängigen Projektteilen. Dazu werden einzelene Projektteile in eigene Repositories ausgegliedert und als *`git`-Submodule* in das Haupt-Repository eingebunden. Solche Submodule können unabhängig vom Haupt-Projekt entwickelt werden und auch in anderen Projekten wiederverwendet werden. Die Integration eines Submoduls erfolgt für einen bestimmten Commit oder ein bestimmtes Tag. Dadurch wird eine differenziertere Qualitätskontrolle möglich. 

#### Microrepo

Bei der Microrepo-Strategie werden alle Projektteile in eigenen Repositories unabhängig voneinander geführt, so dass nur der jeweilige Projektteil und die zugehörige Konfiguration in einem Repository vorliegen. 

Bei der Microrepo-Strategie werden Daten, Code und Konfiguration grundsätzlich immer voneinander getrennt und werden in eigenen Repositories verwaltet. Damit ist diese Strategie die Antithese zum Monorepo. Die Integration der Komponenten erfolgt über das lokale Dateisystem oder über Packetmanager und `git`-Tags.

Diese Strategie eignet sich für Datenprojekte, Projekte mit wenigen direkten Abhähngigkeiten oder Projekte mit verschiedenen Anwendungsgebieten (engl. Deployments). Durch klar getrennte Repositories lassen sich die einzelnen Komponenten in unterschiedlichen Kontexten problemlos unabhängig voneinander publizieren und anpassen. Deshalb ist diese Strategie besonders für Projekte mit sensitiven Daten, wie z.B. Patientendaten, oder Konfigurationen, wie beispielsweise Passwörtern, geeignet, bei denen die Datenverarbeitung keine sensitiven Teile hat.
